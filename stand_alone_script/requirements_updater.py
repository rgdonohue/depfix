#!/usr/bin/env python3
"""
requirements_updater.py

A command‐line tool to parse a Python `requirements.txt` file, determine the latest
available versions of the listed packages on PyPI, optionally filter updates to
patch or minor releases, check for known security vulnerabilities via the OSV API,
and write out an updated requirements file.

This script is intended for use in early prototyping workflows, where you may
inherit autogenerated or stale dependency lists from LLMs and want to quickly
bring them up to date. It performs the following steps:

1. Parse each line of the input requirements file, preserving comments and
   whitespace.
2. For each requirement line that references a PyPI package (e.g. `foo==1.2.3` or
   `bar>=2.0`), query the PyPI JSON API to find the latest compatible version.
   Compatibility is enforced by the supplied constraint (if any) and optional
   semantic versioning policy flags (--minor-only or --patch-only).
3. If --osv-check is enabled, query the OSV vulnerability database for any known
   issues affecting the current and candidate versions of the package. Detected
   vulnerabilities will cause the update to be skipped, unless overridden with
   --ignore-vuln.
4. Write the updated requirements to the specified output file (or stdout).

Limitations:
 - Network access is required to query PyPI and OSV. Without it, the script
   cannot determine available versions or vulnerabilities.
 - Only direct dependencies listed in the input file are updated. Transitive
   dependencies will be resolved when you next run `pip install -r` on the
   generated file.

Example usage:

  python requirements_updater.py --input requirements.txt --output updated.txt \
      --minor-only --osv-check

Author: OpenAI (2025)
"""
from __future__ import annotations

import argparse
import re
import sys
import textwrap
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List, Optional, Tuple

try:
    # packaging provides powerful version parsing and comparison
    from packaging.specifiers import SpecifierSet
    from packaging.version import InvalidVersion, Version
except ImportError as e:
    raise SystemExit("This script requires the `packaging` library. "
                     "Install it via `pip install packaging` and try again.") from e

try:
    import requests
except ImportError:
    raise SystemExit("This script requires the `requests` library. "
                     "Install it via `pip install requests` and try again.")


@dataclass
class RequirementLine:
    """Represents a single line from a requirements file."""

    raw: str                     # The original raw text of the line (including newline)
    name: Optional[str] = None   # Package name, if parsed
    spec: Optional[str] = None   # Version specifier string, e.g. '==1.2.3' or '>=2.0'
    comment: Optional[str] = None  # Trailing inline comment, if any

    @property
    def is_requirement(self) -> bool:
        """Return True if this line references a Python package requirement."""
        return self.name is not None


def parse_requirements(content: Iterable[str]) -> List[RequirementLine]:
    """
    Parse a sequence of lines from a requirements file.

    Supports comments, empty lines, and simple `pkg[extras] specifier` syntax.
    Does not yet handle environment markers (e.g. `; python_version < '3.10'`),
    hashes, or local paths, but preserves them as-is.

    Returns a list of RequirementLine objects preserving the raw text and parsed
    package names/specifiers where possible.
    """
    lines: List[RequirementLine] = []
    for line in content:
        raw = line.rstrip("\n")
        stripped = raw.strip()
        # Preserve blank lines and full-line comments verbatim
        if not stripped or stripped.startswith("#"):
            lines.append(RequirementLine(raw=line))
            continue

        # Split off inline comment
        comment: Optional[str] = None
        if "#" in raw:
            before, _, after = raw.partition("#")
            comment = "#" + after
            stripped = before.strip()

        # Attempt to extract package name and version specifier.
        m = re.match(r"^(?P<name>[A-Za-z0-9_.-]+)(?P<spec>(==|>=|<=|>|<|~=).+)?$", stripped)
        if m:
            name = m.group("name")
            spec = m.group("spec")
            lines.append(RequirementLine(raw=line, name=name, spec=spec, comment=comment))
        else:
            # Could be a URL or path; leave unparsed
            lines.append(RequirementLine(raw=line))
    return lines


def fetch_pypi_versions(package: str) -> List[str]:
    """
    Fetch all available release versions for the given package from PyPI.

    Returns a list of version strings sorted in ascending order.
    Requires network access; raises RuntimeError on HTTP errors.
    """
    url = f"https://pypi.org/pypi/{package}/json"
    try:
        resp = requests.get(url, timeout=10)
    except Exception as exc:
        raise RuntimeError(f"Failed to fetch metadata for {package}: {exc}") from exc
    if resp.status_code != 200:
        raise RuntimeError(f"PyPI returned {resp.status_code} for {package}: {resp.text}")
    data = resp.json()
    releases = data.get("releases", {})
    versions: List[str] = []
    for ver in releases.keys():
        try:
            v = Version(ver)
            if not v.is_prerelease and not v.is_devrelease:
                versions.append(ver)
        except InvalidVersion:
            continue
    versions.sort(key=Version)
    return versions


def latest_compatible_version(available: List[str], spec: Optional[str],
                              minor_only: bool, patch_only: bool) -> Optional[str]:
    """
    Given a list of available versions and an optional version specifier string,
    return the highest version satisfying the spec and optional policy flags.

    If `minor_only` is True, major version changes are disallowed.
    If `patch_only` is True, major and minor version changes are disallowed.
    """
    if not available:
        return None
    pinned_version: Optional[Version] = None
    spec_set = None
    if spec:
        try:
            spec_set = SpecifierSet(spec)
        except Exception:
            spec_set = None
        eq_match = re.match(r"^==\s*([0-9][^, ]*)$", spec.replace(" ", ""))
        if eq_match:
            try:
                pinned_version = Version(eq_match.group(1))
            except InvalidVersion:
                pass
    allowed_major: Optional[int] = None
    allowed_minor: Optional[int] = None
    if (minor_only or patch_only) and pinned_version is not None:
        allowed_major = pinned_version.major
        if patch_only:
            allowed_minor = pinned_version.minor
    candidates: List[Version] = []
    for ver_str in available:
        try:
            ver = Version(ver_str)
        except InvalidVersion:
            continue
        if spec_set and ver not in spec_set:
            continue
        if allowed_major is not None and ver.major != allowed_major:
            continue
        if allowed_minor is not None and ver.minor != allowed_minor:
            continue
        candidates.append(ver)
    if not candidates:
        return None
    return str(sorted(candidates)[-1])


def query_osv(package: str, version: str) -> List[dict]:
    """
    Query the OSV (Open Source Vulnerabilities) API for known vulnerabilities
    affecting the given package and version.

    Returns a list of vulnerability records. Requires network access.
    """
    url = "https://api.osv.dev/v1/query"
    payload = {
        "package": {"name": package, "ecosystem": "PyPI"},
        "version": version
    }
    try:
        resp = requests.post(url, json=payload, timeout=10)
    except Exception as exc:
        raise RuntimeError(f"Failed to query OSV for {package} {version}: {exc}") from exc
    if resp.status_code != 200:
        raise RuntimeError(f"OSV returned {resp.status_code} for {package} {version}: {resp.text}")
    data = resp.json()
    vulns = data.get("vulns", [])
    return vulns if vulns else []


def update_requirements(lines: List[RequirementLine],
                        minor_only: bool,
                        patch_only: bool,
                        osv_check: bool,
                        ignore_vuln: bool) -> Tuple[List[str], List[str]]:
    """
    Given parsed requirement lines, produce updated lines and collect change notes.

    Returns a tuple (updated_lines, notes) where updated_lines are the strings
    to be written and notes is a list of human‐readable messages describing
    actions taken (e.g. updates skipped due to vulnerabilities).
    """
    updated: List[str] = []
    notes: List[str] = []
    for req in lines:
        if not req.is_requirement:
            updated.append(req.raw)
            continue
        package = req.name
        spec = req.spec
        comment = req.comment or ""
        try:
            avail = fetch_pypi_versions(package)
        except Exception as exc:
            notes.append(f"Failed to fetch versions for {package}: {exc}")
            updated.append(req.raw)
            continue
        latest = latest_compatible_version(avail, spec, minor_only, patch_only)
        if latest is None:
            updated.append(req.raw)
            continue
        current_version = None
        if spec and spec.strip().startswith("=="):
            try:
                current_version = Version(spec.split("==")[1].strip())
            except Exception:
                pass
        if current_version is not None and str(current_version) == latest:
            updated.append(req.raw)
            continue
        if osv_check:
            vulns = query_osv(package, latest)
            if vulns and not ignore_vuln:
                notes.append(
                    f"Skipped update for {package}: {latest} has {len(vulns)} known vulnerability(ies)."
                )
                updated.append(req.raw)
                continue
        new_line = f"{package}=={latest}"
        if comment:
            new_line += " " + comment
        updated.append(new_line)
        old_ver_str = str(current_version) if current_version is not None else spec or ""
        notes.append(f"Updated {package} {old_ver_str} -> {latest}")
    return updated, notes


def main(argv: Optional[Iterable[str]] = None) -> int:
    parser = argparse.ArgumentParser(
        description="Update Python requirements.txt to latest compatible versions",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=textwrap.dedent(
            """
            This tool reads an input requirements file, determines the latest compatible
            versions of each package available on PyPI, optionally checks for known
            vulnerabilities, and writes a new requirements file. Compatibility
            constraints can be enforced via existing specifiers and flags:

              --minor-only  Only allow minor and patch updates (pin major version)
              --patch-only  Only allow patch updates (no major or minor version changes)

            Vulnerability checking is performed via the OSV API. If a candidate
            update has known vulnerabilities, it will be skipped unless --ignore-vuln
            is used.

            Examples:

              # Update all packages to latest version, ignoring vulnerabilities
              python requirements_updater.py -i reqs.txt -o reqs.new.txt --ignore-vuln

              # Update only patch releases and perform OSV checks
              python requirements_updater.py -i reqs.txt --patch-only --osv-check
            """
        )
    )
    parser.add_argument("-i", "--input", type=Path, required=True,
                        help="Path to input requirements.txt file")
    parser.add_argument("-o", "--output", type=Path,
                        help="Path to write updated requirements file (default: overwrite input)")
    parser.add_argument("--minor-only", action="store_true",
                        help="Allow minor and patch updates but not major version bumps")
    parser.add_argument("--patch-only", action="store_true",
                        help="Allow only patch updates (no major or minor version changes)")
    parser.add_argument("--osv-check", action="store_true",
                        help="Check OSV database for vulnerabilities before updating")
    parser.add_argument("--ignore-vuln", action="store_true",
                        help="Ignore OSV results and update even if vulnerabilities are found")

    args = parser.parse_args(argv)

    if args.patch_only and args.minor_only:
        print("Error: --patch-only and --minor-only cannot be used together", file=sys.stderr)
        return 1

    try:
        content = args.input.read_text().splitlines(True)
    except Exception as exc:
        print(f"Failed to read input file {args.input}: {exc}", file=sys.stderr)
        return 1

    req_lines = parse_requirements(content)
    updated_lines, notes = update_requirements(
        req_lines,
        minor_only=args.minor_only,
        patch_only=args.patch_only,
        osv_check=args.osv_check,
        ignore_vuln=args.ignore_vuln,
    )

    output_path = args.output or args.input
    try:
        with output_path.open("w", encoding="utf-8") as fh:
            for line in updated_lines:
                fh.write(line if line.endswith("\n") else line + "\n")
    except Exception as exc:
        print(f"Failed to write output file {output_path}: {exc}", file=sys.stderr)
        return 1

    if notes:
        print("Changes:")
        for note in notes:
            print("  -", note)
    else:
        print("No updates were necessary.")
    return 0


if __name__ == "__main__":
    sys.exit(main())